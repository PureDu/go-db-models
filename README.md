# go-db-models

根据配置参数自动创建所有数据表的struct结构，每个结构独立为一个文件。

## 主要功能

- [x] 生成表结构
- [ ] 将字典表的数据固化在代码里

## INSTALL

```sh
go get -u github.com/ibbd-dev/go-db-models
```

## USAGE

```sh
# 生成struct
go-db-models -h host -d database -u username -p password -n packageName {json-file.json}

# 帮助
go-db-models
```

生成的文件:

- 公共配置文件`common_gen_go`
- 表结构及查询文件`*_tb_gen.go`, 主要包含以下几部分内容：
  - 表结构定义
  - 单行结果查询函数
  - 根据某个字段查询单行记录的函数，例如根据id字段进行查询
  - 多行结果查询函数
  - 返回多行结果时，可以选择生成list（默认）或map格式
- 单元测试文件`*_tb_gen_test.go`

`*_tb_gen.go`文件样例如下：

```go
// DON'T EDIT *** generated by go-db-models *** DON'T EDIT //
package test

import "strings"
import "database/sql"

// 对应数据表：ad_project
type AdProjectTable struct {
	Id     uint32         `name:"id"`
	PlanId uint32         `name:"plan_id"`
	Name   string         `name:"name"`
	Status uint8          `name:"status"`
	Remark sql.NullString `name:"remark"`
}

const adProjectSelectFields string = "`id`,`plan_id`,`name`,`status`,`remark`"

// 查询单行记录（根据某个字段）
func AdProjectQueryById(db *sql.DB, idVal uint32) (ad_project *AdProjectTable, err error) {
	queryString := "SELECT " + adProjectSelectFields + " FROM `ad_project` WHERE `id` = ?"
	ad_project = &AdProjectTable{}
	err = db.QueryRow(queryString, idVal).Scan(
		&ad_project.Id,
		&ad_project.PlanId,
		&ad_project.Name,
		&ad_project.Status,
		&ad_project.Remark,
	)

	if err != nil {
		return nil, err
	}

	return ad_project, nil
}

// 查询单行记录
func AdProjectQueryRow(db *sql.DB, queryString string) (ad_project *AdProjectTable, err error) {
	queryString = strings.Replace(queryString, SelectFieldsTemp, adProjectSelectFields, 1)
	ad_project = &AdProjectTable{}
	err = db.QueryRow(queryString).Scan(
		&ad_project.Id,
		&ad_project.PlanId,
		&ad_project.Name,
		&ad_project.Status,
		&ad_project.Remark,
	)

	if err != nil {
		return nil, err
	}

	return ad_project, nil
}

// 查询多行记录
func AdProjectQuery(db *sql.DB, queryString string) (ad_project []*AdProjectTable, err error) {
	queryString = strings.Replace(queryString, SelectFieldsTemp, adProjectSelectFields, 1)
	rows, err := db.Query(queryString)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var oneRow = &AdProjectTable{}
		err = rows.Scan(
			&oneRow.Id,
			&oneRow.PlanId,
			&oneRow.Name,
			&oneRow.Status,
			&oneRow.Remark,
		)
		if err != nil {
			return nil, err
		}

		ad_project = append(ad_project, oneRow)
	}

	return ad_project, nil
}
```

## 生成单元测试文档

在生成相应的结构和查询函数的同时，也会生成相应的单元测试文件，单元测试文件的文件名如`*_tb_gen_test.go`，连接数据库时，使用了一个`testGetDb`的函数，需要在外部自己实现，如`vim init_test.go`:

```go
package models

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

const (
	testHost     string = "dsp-dev-go"
	testDB       string = "dsp_sys"
	testUser     string = "dsp_sys"
	testPassword string = "Dsp_sys-pwd"
	testPort     int    = 3306
)

// 获取数据库连接
// 单元测试文件会调用该方法获得数据库链接
func testGetDb() *sql.DB {
	// Open database connection
	conn_string := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s", testUser, testPassword, testHost, testPort, testDB)

	db, err := sql.Open("mysql", conn_string)
	if err != nil {
		panic(err)
	}

	return db
}
```

## Json数据表定义文件

如果只是希望生成部分的数据表，则可以使用该文件。该文件的结构如：

```json
{
    // 需要生成的数据表
    "tables": [
        {
            // 数据表的名字
            "name": "ad_plan",
            // 需要生成的字段
            "fields": ["id", "name", "status", "daily_budget", "start_date", "created_at"],
            // [可选]这是可选项，如果定义了该字段，则会自动生成一个类似QueryById的查询函数。
            "queryBy": "id",
            // [可选]返回多行数据时，默认返回格式是list，但是可以通过指定该字段，来返回map结构，其下标就是对应的字段的值。
            // 该字段通常是主键或者唯一索引的字段，否则就可能出现重复值
            "mapIndex": "id",
            // [可选]结构体增加注释
            "msg": "这是注释。。。"
        },
        {
            "name": "ad_project",
            "fields": ["id", "plan_id", "name", "status", "remark"]
        }
    ]
}
```

## TODO

- 查询缓存
- 连表查询

